<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · RTMsim</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="RTMsim logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">RTMsim</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">RTMsim</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#API-Functions"><span>API Functions</span></a></li><li><a class="tocitem" href="#Additional-features"><span>Additional features</span></a></li></ul></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../parameters/">Input parameters</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/obertscheiderfhwn/RTMsim/blob/main/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><p>Alternatively to using the GUI, one has access to all the functions after installing the package.</p><h2 id="API-Functions"><a class="docs-heading-anchor" href="#API-Functions">API Functions</a><a id="API-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#API-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="rtmsim.start_rtmsim-Tuple{Any}" href="#rtmsim.start_rtmsim-Tuple{Any}"><code>rtmsim.start_rtmsim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">start_rtmsim(inputfilename)</code></pre><p>Reads the text input file and calls the solver with the read parameters. </p><p>Arguments:</p><ul><li>inputfilename :: String</li></ul><p>The complete set of input parameters can be accessed in the input file. The following paragraph shows an example for such an input file:</p><pre><code class="nohighlight hljs">    1    #i_model 
    meshfiles/mesh_permeameter1_foursets.bdf    #meshfilename 
    200    #tmax 
    1.01325e5 1.225 1.4 0.06    #p_ref rho_ref gamma mu_resin_val 
    1.35e5 1.0e5    #p_a_val p_init_val 
    3e-3 0.7 3e-10 1 1 0 0    #t_val porosity_val K_val alpha_val refdir1_val refdir2_val refdir3_val 
    3e-3 0.7 3e-10 1 1 0 0    #t1_val porosity1_val K1_val alpha1_val refdir11_val refdir21_val refdir31_val 
    3e-3 0.7 3e-10 1 1 0 0    #t2_val porosity2_val K2_val alpha2_val refdir12_val refdir22_val refdir32_val
    3e-3 0.7 3e-10 1 1 0 0    #t3_val porosity3_val K3_val alpha3_val refdir13_val refdir23_val refdir33_val
    3e-3 0.7 3e-10 1 1 0 0    #t4_val porosity4_val K4_val alpha4_val refdir14_val refdir24_val refdir34_val 
    1 0 0 0    #patchtype1val patchtype2val patchtype3val patchtype4val 
    0 results.jld2    #i_restart restartfilename
    0 0.01    #i_interactive r_p
    16    #n_pics</code></pre><p>Meaning of the variables:</p><ul><li><code>i_model</code>: Identifier for physical model (Default value is 1)</li><li><code>meshfilename</code>: Mesh filename.</li><li><code>tmax</code>: Maximum simulation time.</li><li><code>p_ref rho_ref gamma mu_resin_val</code>: Parameters for the adiabatic equation of state and dynamic viscosity of resin used in the Darcy term.</li><li><code>p_a_val p_init_val</code>: Absolut pressure value for injection port and for initial cavity pressure.</li><li><code>t_val porosity_val K_val alpha_val refdir1_val refdir2_val refdir3_val</code>: Properties of the cells in the main preform: The vector <code>(refdir1_val,refdir2_val,refdir3_val)</code> is projected onto the cell in order to define the first principal cell direction. The second principal cell direction is perpendicular to the first one in the plane spanned by the cell nodes. The principal cell directions are used as the principal permeabilty directions. The cell properties are defined by the thickness <code>t_val</code>, the porosity <code>porosity_val</code>, the permeability <code>K_val</code> in the first principal cell direction, the permeablity <code>alpha_val</code> in the second principal direction.</li><li><code>t1_val porosity1_val K1_val alpha1_val refdir11_val refdir21_val refdir31_val</code> etc.: Properties for up to four additional cell regions if preform. </li><li><code>patchtype1val patchtype2val patchtype3val patchtype4val</code>: These regions are used to specify the location of the pressure boundary conditions and to specify regions with different permeability, porosity and thickness properties (e.g. for different part thickness and layup or for race tracking which are regions with very high permeability typically at the boundary of the preforms). Vents need not be specified. Parameters <code>patchtype1val</code> define the patch type. Numerical values 0, 1, 2 and 3 are allowed with the following interpretation:<ul><li>0 .. the patch is ignored</li><li>1 .. the patch represents an inlet gate, where the specified injection pressure level applies</li><li>2 .. the patch specifies a preform region</li><li>3 .. the patch represents a vent, where the specified initial pressure level applies</li></ul></li><li><code>i_restart restartfilename</code>: Start with new simulation if <code>0</code> or continue previous simulation if <code>1</code> from specified file</li><li><code>i_interactive r_p</code>: Select the inlet ports graphically if i_interactive equal to <code>1</code> and inlet ports have specified radius</li><li><code>n_pics</code>: Number of intermediate output files, supposed to be a multiple of <code>4</code></li></ul><p>Entries are separated by one blank.</p><p>Unit test:</p><ul><li><code>MODULE_ROOT=splitdir(splitdir(pathof(rtmsim))[1])[1]; inputfilename=joinpath(MODULE_ROOT,&quot;inputfiles&quot;,&quot;input.txt&quot;); rtmsim.start_rtmsim(inputfilename);</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.rtmsim_rev1-Tuple{Any}" href="#rtmsim.rtmsim_rev1-Tuple{Any}"><code>rtmsim.rtmsim_rev1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rtmsim_rev1(param)</code></pre><p>RTMsim solver with the following main steps:</p><ul><li>Simulation initialization</li><li>Read mesh file and prepare patches  </li><li>Find neighbouring cells</li><li>Assign parameters to cells</li><li>Create local cell coordinate systems</li><li>Calculate initial time step</li><li>Array initialization</li><li>Define simulation time and intermediate output times</li><li>Boundary conditions</li><li>(Optional initialization if <code>i_model=2,3,..</code>)</li><li>Time evolution (for loops over all indices inside a while loop for time evolution)<ul><li>Calculation of correction factors for cell thickness, porosity, permeability, viscosity</li><li>Pressure gradient calculation</li><li>Numerical flux function calculation</li><li>Update of rho, u, v, gamma and p according to conservation laws and equation of state</li><li>Boundary conditions</li><li>Prepare arrays for next time step</li><li>Saving of intermediate data</li><li>(Opional time marching etc. for i_model=2,3,...)</li><li>Calculation of adaptive time step </li></ul></li></ul><p>Arguments: Data structure <code>param</code> with</p><ul><li><code>i_model :: Int64 =1</code></li><li><code>meshfilename :: String =&quot;input.txt&quot;</code></li><li><code>tmax :: Float64 =200</code></li><li><code>p_ref :: Float64 =1.01325e5</code></li><li><code>rho_ref :: Float64 =1.225</code></li><li><code>gamma :: Float64 =1.4</code></li><li><code>mu_resin_val :: Float64 =0.06</code></li><li><code>p_a_val :: Float64 =1.35e5</code></li><li><code>p_init_val :: Float64 =1.0e5</code>  </li><li><code>t_val :: Float64 =3e-3</code></li><li><code>porosity_val :: Float64 =0.7</code></li><li><code>K_val :: Float64 =3e-10</code></li><li><code>alpha_val :: Float64 =1.0</code></li><li><code>refdir1_val :: Float64 =1.0</code></li><li><code>refdir2_val :: Float64 =0.0</code></li><li><code>refdir3_val :: Float64 =0.0</code></li><li><code>t1_val :: Float64 =3e-3</code></li><li><code>porosity1_val :: Float64 =0.7</code></li><li><code>K1_val :: Float64 =3e-10</code></li><li><code>alpha1_val :: Float64 =1.0</code></li><li><code>refdir11_val :: Float64 =1.0</code></li><li><code>refdir21_val :: Float64 =0.0</code></li><li><code>refdir31_val :: Float64 =0.0</code></li><li><code>t2_val :: Float64 =3e-3</code></li><li><code>porosity2_val :: Float64 =0.7</code></li><li><code>K2_val :: Float64 =3e-10</code></li><li><code>alpha2_val :: Float64 =1.0</code></li><li><code>refdir12_val :: Float64 =1.0</code></li><li><code>refdir22_val :: Float64 =0.0</code></li><li><code>refdir32_val :: Float64 =0.0</code></li><li><code>t3_val :: Float64 =3e-3</code></li><li><code>porosity3_val :: Float64 =0.7</code></li><li><code>K3_val :: Float64 =3e-10</code></li><li><code>alpha3_val :: Float64 =1.0</code></li><li><code>refdir13_val :: Float64 =0.0</code></li><li><code>refdir23_val :: Float64 =0.0</code></li><li><code>refdir33_val :: Float64 =0.0</code></li><li><code>t4_val :: Float64 =3e-3</code></li><li><code>porosity4_val :: Float64 =0.7</code></li><li><code>K4_val :: Float64 =3e-10</code></li><li><code>alpha4_val :: Float64 =1.0</code></li><li><code>refdir14_val :: Float64 =1.0</code></li><li><code>refdir24_val :: Float64 =0.0</code></li><li><code>refdir34_val :: Float64 =0.0</code></li><li><code>patchtype1val :: Int64 =1</code></li><li><code>patchtype2val :: Int64 =0</code></li><li><code>patchtype3val :: Int64 =0</code></li><li><code>patchtype4val :: Int64 =0</code></li><li><code>i_restart :: Int64 =0</code></li><li><code>restartfilename :: String =&quot;results.jld2&quot;</code></li><li><code>i_interactive :: Int64 =0</code></li><li><code>r_p :: Float64 =0.01</code></li><li><code>n_pics :: Int64 =16</code></li></ul><p>Meaning of the variables:</p><ul><li><code>i_model</code>: Identifier for physical model (Default value is 1)</li><li><code>meshfilename</code>: Mesh filename.</li><li><code>tmax</code>: Maximum simulation time.</li><li><code>p_ref rho_ref gamma mu_resin_val</code>: Parameters for the adiabatic equation of state and dynamic viscosity of resin used in the Darcy term.</li><li><code>p_a_val p_init_val</code>: Absolut pressure value for injection port and for initial cavity pressure.</li><li><code>t_val porosity_val K_val alpha_val refdir1_val refdir2_val refdir3_val</code>: Properties of the cells in the main preform: The vector <code>(refdir1_val,refdir2_val,refdir3_val)</code> is projected onto the cell in order to define the first principal cell direction. The second principal cell direction is perpendicular to the first one in the plane spanned by the cell nodes. The principal cell directions are used as the principal permeabilty directions. The cell properties are defined by the thickness <code>t_val</code>, the porosity <code>porosity_val</code>, the permeability <code>K_val</code> in the first principal cell direction, the permeablity <code>alpha_val</code> in the second principal direction.</li><li><code>t1_val porosity1_val K1_val alpha1_val refdir11_val refdir21_val refdir31_val</code> etc.: Properties for up to four additional cell regions if preform. </li><li><code>patchtype1val patchtype2val patchtype3val patchtype4val</code>: These regions are used to specify the location of the pressure boundary conditions and to specify regions with different permeability, porosity and thickness properties (e.g. for different part thickness and layup or for race tracking which are regions with very high permeability typically at the boundary of the preforms). Vents need not be specified. Parameters <code>patchtype1val</code> define the patch type. Numerical values 0, 1, 2 and 3 are allowed with the following interpretation:<ul><li>0 .. the patch is ignored</li><li>1 .. the patch represents an inlet gate, where the specified injection pressure level applies</li><li>2 .. the patch specifies a preform region</li><li>3 .. the patch represents a vent, where the specified initial pressure level applies</li></ul></li><li><code>i_restart restartfilename</code>: Start with new simulation if <code>0</code> or continue previous simulation if <code>1</code> from specified file</li><li><code>i_interactive r_p</code>: Select the inlet ports graphically if i_interactive equal to <code>1</code> and inlet ports have specified radius</li><li><code>n_pics</code>: Number of intermediate output files, supposed to be a multiple of <code>4</code></li></ul><p>Unit tests:</p><ul><li><code>MODULE_ROOT=splitdir(splitdir(pathof(rtmsim))[1])[1]; meshfilename=joinpath(MODULE_ROOT,&quot;meshfiles&quot;,&quot;mesh_permeameter1_foursets.bdf&quot;); param=rtmsim.input_vals(1,meshfilename,200, 101325,1.225,1.4,0.06, 1.35e5,1.00e5, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-11,1,1,0,0, 3e-3,0.7,3e-11,1,1,0,0, 3e-3,0.7,3e-9,1,1,0,0, 1,2,2,2,0,&quot;results.jld2&quot;,0,0.01,16); rtmsim.rtmsim_rev1(param);</code></li></ul><p>Addtional unit tests:</p><ul><li><code>MODULE_ROOT=splitdir(splitdir(pathof(rtmsim))[1])[1]; meshfilename=joinpath(MODULE_ROOT,&quot;meshfiles&quot;,&quot;mesh_permeameter1_foursets.bdf&quot;); param=rtmsim.input_vals(1,meshfilename,200, 101325,1.225,1.4,0.06, 1.35e5,1.00e5, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-11,1,1,0,0, 3e-3,0.7,3e-11,1,1,0,0, 3e-3,0.7,3e-9,1,1,0,0, 1,0,0,0, 0,&quot;results.jld2&quot;,0,0.01,16); rtmsim.rtmsim_rev1(param);</code> for starting a simulation with one pressure inlet port (sets 2, 3 and 4 are not used and consequently the preform parameters are ignored; since set 1 is a pressure inlet, also the parameters for set 1 are ignored and the only relevant parameter for the specified set is the pressure difference between injection and initial cavity pressure)</li><li><code>MODULE_ROOT=splitdir(splitdir(pathof(rtmsim))[1])[1]; meshfilename=joinpath(MODULE_ROOT,&quot;meshfiles&quot;,&quot;mesh_permeameter1_foursets.bdf&quot;); param=rtmsim.input_vals(1,meshfilename,200, 101325,1.225,1.4,0.06, 1.35e5,1.00e5, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-11,1,1,0,0, 3e-3,0.7,3e-11,1,1,0,0, 3e-3,0.7,3e-9,1,1,0,0, 1,2,2,2, 0,&quot;results.jld2&quot;,0,0.01,16); rtmsim.rtmsim_rev1(param);</code> for starting a simulation with different patches and race tracking</li><li><code>MODULE_ROOT=splitdir(splitdir(pathof(rtmsim))[1])[1]; meshfilename=joinpath(MODULE_ROOT,&quot;meshfiles&quot;,&quot;mesh_permeameter1_foursets.bdf&quot;); param=rtmsim.input_vals(1,meshfilename,200, 101325,1.225,1.4,0.06, 1.35e5,1.00e5, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-11,1,1,0,0, 3e-3,0.7,3e-11,1,1,0,0, 3e-3,0.7,3e-9,1,1,0,0, 1,2,2,2, 1,&quot;results.jld2&quot;,0,0.01,16); rtmsim.rtmsim_rev1(param);</code> for continuing the previous simulation   </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.plot_mesh-Tuple{Any, Any}" href="#rtmsim.plot_mesh-Tuple{Any, Any}"><code>rtmsim.plot_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function plot_mesh(meshfilename,i_mode)</code></pre><p>Create mesh plot with cells with <code>i_mode==1</code> and create mesh plots with cell center nodes with <code>i_mode==2</code> for manual selection of inlet ports.</p><p>Arguments:</p><ul><li>meshfilename :: String</li><li>i_mode :: Int</li></ul><p>Unit test:</p><ul><li><code>MODULE_ROOT=splitdir(splitdir(pathof(rtmsim))[1])[1]; meshfilename=joinpath(MODULE_ROOT,&quot;meshfiles&quot;,&quot;mesh_permeameter1_foursets.bdf&quot;); rtmsim.plot_mesh(meshfilename,1);</code></li></ul><p>Additional unit tests:</p><ul><li><code>MODULE_ROOT=splitdir(splitdir(pathof(rtmsim))[1])[1]; meshfilename=joinpath(MODULE_ROOT,&quot;meshfiles&quot;,&quot;mesh_permeameter1_foursets.bdf&quot;); rtmsim.plot_mesh(meshfilename,2);</code> for the manual selection of inlet ports with left mouse button click while key p is pressed </li><li><code>MODULE_ROOT=splitdir(splitdir(pathof(rtmsim))[1])[1]; meshfilename=joinpath(MODULE_ROOT,&quot;meshfiles&quot;,&quot;mesh_permeameter1_foursets.bdf&quot;); param=rtmsim.input_vals(1,meshfilename,200, 0.35e5,1.205,1.4,0.06, 0.35e5,0.00e5, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-10,1,1,0,0, 3e-3,0.7,3e-10,1,1,0,0, 0,0,0,0, 0,&quot;results.jld2&quot;,1,0.01,16); rtmsim.rtmsim_rev1(param);</code> for starting only with the interactively selected inlet ports</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.plot_sets-Tuple{Any}" href="#rtmsim.plot_sets-Tuple{Any}"><code>rtmsim.plot_sets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function plot_sets(meshfilename)</code></pre><p>Create a plot with the up to four cell sets defined in the mesh file.</p><p>Unit test:</p><ul><li><code>MODULE_ROOT=splitdir(splitdir(pathof(rtmsim))[1])[1]; meshfilename=joinpath(MODULE_ROOT,&quot;meshfiles&quot;,&quot;mesh_permeameter1_foursets.bdf&quot;); rtmsim.plot_sets(meshfilename);</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.read_nastran_mesh-Tuple{Any}" href="#rtmsim.read_nastran_mesh-Tuple{Any}"><code>rtmsim.read_nastran_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function read_nastran_mesh(input_struct)</code></pre><p>Read file in Nastran format with fixed length (8 digits), nodes (<code>GRIDS</code>) defined in global coordinate system.</p><p>Arguments:</p><ul><li><code>meshfilename :: String</code></li><li><code>paramset, paramset1, paramset2, paramset3, paramset3 :: Vector{Float}</code></li><li><code>patchtype1val,patchtype1val1,patchtype1val2,patchtype1val3,patchtype1val4 :: Int</code></li><li><code>i_interactive :: Int</code></li><li><code>r_p :: Float</code></li></ul><p>Unit test:</p><ul><li><code>MODULE_ROOT=splitdir(splitdir(pathof(rtmsim))[1])[1]; meshfilename=joinpath(MODULE_ROOT,&quot;meshfiles&quot;,&quot;mesh_permeameter1_foursets.bdf&quot;); paramset=[0.5,0.3,3e-10,1.0,1.0,0.0,0.0];paramset1=paramset;paramset2=paramset;paramset3=paramset;paramset4=paramset;patchtype1val=-1;patchtype2val=-1;patchtype3val=-1;patchtype4val=-1;i_interactive=0;r_p=0.01; input_struct=rtmsim.input_args_read_mesh(meshfilename,paramset,paramset1,paramset2,paramset3,paramset4,patchtype1val,patchtype2val,patchtype3val,patchtype4val,i_interactive,r_p); return_struct=rtmsim.read_mesh(input_struct);</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.plot_results-Tuple{Any}" href="#rtmsim.plot_results-Tuple{Any}"><code>rtmsim.plot_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function plot_results(resultsfilename)</code></pre><p>Create contour plots of the filling factor and the pressure after loading a results file.</p><p>Arguments:</p><ul><li>resultsfilename :: String </li></ul><p>Unit test: </p><ul><li><code>WORK_DIR=pwd(); resultsfilename=joinpath(WORK_DIR,&quot;results.jld2&quot;); rtmsim.plot_results(resultsfilename);</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.plot_overview-Tuple{Any, Any}" href="#rtmsim.plot_overview-Tuple{Any, Any}"><code>rtmsim.plot_overview</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function plot_overview(n_out,n_pics)</code></pre><p>Create filling factor contour plots. <code>n_out</code> is the index of the last output file, if <code>n_out==-1</code> the output file with the highest index is chosen. Consider the last <code>n_pics</code> for creating the contour plots at four equidistant time intervals, if <code>n_pics==-1</code> all available output files are considered.</p><p>Arguments:</p><ul><li>n_out :: Int</li><li>n_pics :: Int</li></ul><p>Unit test: </p><ul><li><code>rtmsim.plot_overview(-1,-1)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.plot_filling-Tuple{Any, Any}" href="#rtmsim.plot_filling-Tuple{Any, Any}"><code>rtmsim.plot_filling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function plot_filling(n_out,n_pics)</code></pre><p>Create a window showing the filling factor contour plot at a selected time instance. Selection is with slider bar. <code>n_out</code> is the index of the last output file, if <code>n_out==-1</code> the output file with the highest index is chosen. Consider the last <code>n_pics</code> for creating the contour plots at four equidistant time intervals, if <code>n_pics==-1</code> all available output files are considered.</p><p>Arguments: </p><ul><li>n_out :: Int</li><li>n_pics :: Int</li></ul><p>Unit test:</p><ul><li><code>rtmsim.plot_filling(-1,-1)</code> </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.gui-Tuple{}" href="#rtmsim.gui-Tuple{}"><code>rtmsim.gui</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function gui()</p><p>Opens the GUI.</p><p>No arguments. </p><p>Unit test:</p><ul><li><code>rtmsim.gui();</code> to open the GUI.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.numerical_gradient-Tuple{Any}" href="#rtmsim.numerical_gradient-Tuple{Any}"><code>rtmsim.numerical_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function numerical_gradient(input_struct)</code></pre><p>Calculates the pressure gradient from the cell values of the neighbouring cells.</p><ul><li><code>i_method=1</code> .. Least square solution to determine gradient</li><li><code>i_method=2</code> .. Least square solution to determine gradient with limiter</li><li><code>i_method=3</code> .. RUntime optimized least square solution to determine gradient</li></ul><p>Arguments: Data structure with</p><ul><li><code>i_method :: Int</code></li><li><code>ind :: Int</code></li><li><code>p_old :: Vector{Float}</code></li><li><code>cellneighoursarray :: Array{Float,2}</code></li><li><code>cellcentertocellcenterx, cellcentertocellcentery :: Array{Float,2}</code></li></ul><p>Return: Data structure with</p><ul><li><code>dpdx :: Float</code></li><li><code>dpdy :: Float</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.numerical_flux_function-Tuple{Any}" href="#rtmsim.numerical_flux_function-Tuple{Any}"><code>rtmsim.numerical_flux_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function numerical_flux_function(input_struct)</code></pre><p>Evaluates the numerical flux functions at the cell boundaries. -<code>i_method==1</code> .. first order upwinding</p><p>Arguments: Data structure with</p><ul><li><code>i_method :: Int</code></li><li><code>vars_P, vars_A :: 4-element Vector{Float}</code></li><li><code>meshparameters :: 3-element Vector{Float}</code></li></ul><p>Return: Data structure with</p><ul><li><code>F_rho_num_add :: Float</code></li><li><code>F_u_num_add :: Float</code></li><li><code>F_v_num_add :: Float</code></li><li><code>F_gamma_num_add :: Float</code></li><li><code>F_gamma_num1_add :: Float</code></li></ul><p>Unit tests:</p><ul><li>Comparison with flux function for one-dimensional case without upwinding for the continuity equation and with upwinding in the momentum equation, i.e. F<em>rho=(rho*u)</em>withoutupwinding=0.5<em>(1.0+1.0)</em>0.5<em>(1.2+0.4)=0.8 and F_u=(rho</em>u)<em>withoutupwinding*u</em>withupwinding=0.8<em>1.2=0.96 in density equation without upwinding and rho</em>u without upwinding. rho=1.0 in considered and neighbouring cell, u=1.2 in considered cell and u=0.4 in neighbouring cell, v=0 and gamma=0 in considered and neighbouring cell. <code>input_struct=rtmsim.input_args_flux(1,[1.0; 1.2; 0.0; 0.0],[1.0; 0.4; 0.0; 0.0],[1.0;0.0;1.0]);return_struct=rtmsim.numerical_flux_function(input_struct);println(&quot;F_rho=&quot;*string(return_struct.F_rho_num_add)*&quot;, F_u=&quot;*string(return_struct.F_u_num_add))</code> with result <code>F_rho=0.8, F_u=0.96</code></li><li>General case with [rho,u,v,gamma]=[1.225,1.2,0.4,0.9] in the considered cell and [rho,u,v,gamma]=[1.225,1.2,0.4,0.9] in the neighbouring cell and outwards pointing cell normal vector [1/sqrt(2),1/sqrt(2)] and boundary face area 1.0. <code>input_struct=rtmsim.input_args_flux(1,[1.225; 1.2; 0.4; 0.9],[1.0; 0.4; 1.2; 0.1],[1/sqrt(2);1/sqrt(2);1.0]);return_struct=rtmsim.numerical_flux_function(input_struct);println(&quot;F_rho=&quot;*string(return_struct.F_rho_num_add)*&quot;, F_u=&quot;*string(return_struct.F_u_num_add)*&quot;, F_v=&quot;*string(return_struct.F_v_num_add)*&quot;, F_gamma=&quot;*string(return_struct.F_gamma_num_add)*&quot;, F_gamma_num1=&quot;*string(return_struct.F_gamma_num1_add))</code> with result <code>F_rho=1.2586500705120547, F_u=1.5103800846144655, F_v=0.5034600282048219, F_gamma=1.0182337649086284, F_gamma_num1=1.131370849898476</code> </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.numerical_flux_function_boundary-Tuple{Any}" href="#rtmsim.numerical_flux_function_boundary-Tuple{Any}"><code>rtmsim.numerical_flux_function_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">numerical_flux_function_boundary(input_struct)</code></pre><p>Evaluates the numerical flux functions at the cell boundaries to pressure inlet or outlet.</p><ul><li><code>i_method==1</code> .. first order upwinding</li></ul><p>Arguments: Data structure with</p><ul><li><code>i_method :: Int</code></li><li><code>vars_P, vars_A ::</code> 4-element <code>Vector{Float}</code></li><li><code>meshparameters ::</code> 3-element <code>Vector{Float}</code></li><li><code>n_dot_u :: Float</code></li></ul><p>Return: Data structure with</p><ul><li><code>F_rho_num_add :: Float</code></li><li><code>F_u_num_add :: Float</code></li><li><code>F_v_num_add :: Float</code></li><li><code>F_gamma_num_add :: Float</code></li><li><code>F_gamma_num1_add :: Float</code> </li></ul><p>Unit tests:</p><ul><li>One-dimensional inflow from a cell with rho=1.0 with u=1.2 into the considered cell. <code>input_struct=rtmsim.input_args_flux_boundary(1,[1.0; 1.2; 0.0; 0.0],[1.0; 0.0; 0.0; 0.0],[1.0;0.0;1.0],1.2);return_struct=rtmsim.numerical_flux_function(input_struct);println(&quot;F_rho=&quot;*string(return_struct.F_rho_num_add)*&quot;, F_u=&quot;*string(return_struct.F_u_num_add))</code> with result <code>F_rho=0.6, F_u=0.72</code></li><li>General case <code>input_struct=rtmsim.input_args_flux_boundary(1,[1.225; 1.2; 0.4; 0.9],[1.0; 0.4; 1.2; 0.1],[1/sqrt(2);1/sqrt(2);1.0],-0.8);return_struct=rtmsim.numerical_flux_function_boundary(input_struct);println(&quot;F_rho=&quot;*string(return_struct.F_rho_num_add)*&quot;, F_u=&quot;*string(return_struct.F_u_num_add)*&quot;, F_v=&quot;*string(return_struct.F_v_num_add)*&quot;, F_gamma=&quot;*string(return_struct.F_gamma_num_add)*&quot;, F_gamma_num1=&quot;*string(return_struct.F_gamma_num1_add))</code> with result <code>F_rho=-0.8900000000000001, F_u=-0.3560000000000001, F_v=-1.068, F_gamma=-0.08000000000000002, F_gamma_num1=-0.8</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.create_coordinate_systems-Tuple{Any}" href="#rtmsim.create_coordinate_systems-Tuple{Any}"><code>rtmsim.create_coordinate_systems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function create_coordinate_systems(input_struct)</code></pre><p>Define the local cell coordinate system and the transformation matrix from the local cell coordinate system from the neighbouring cell to the local cell coordinate system of the considered cell.</p><p>Arguments: Data structure with</p><ul><li><code>N :: Int</code></li><li><code>cellgridid :: Array{Int,2}</code></li><li><code>gridx :: Vector{Float}</code></li><li><code>gridy :: Vector{Float}</code></li><li><code>gridz :: Vector{Float}</code></li><li><code>cellcenterx :: Vector{Float}</code></li><li><code>cellcentery :: Vector{Float}</code></li><li><code>cellcenterz :: Vector{Float}</code></li><li><code>faces :: Array{Int,2}</code></li><li><code>cellneighboursarray :: Array{Int,2}</code></li><li><code>celldirection :: Array{Float,2}</code></li><li><code>cellthickness :: Vector{Float}</code></li><li><code>maxnumberofneighbours :: Int</code></li></ul><p>Meaning of the arguments:</p><ul><li><code>N</code>: Number of cells</li><li><code>cellgridid</code>: The i-th line contains the three IDs of the nodes which form the cell</li><li><code>gridx</code>,<code>gridy</code>,<code>gridz</code>: i-th component of these vectors contain the x, y and z coordinates of node with ID i</li><li><code>cellcenterx</code>,<code>cellcentery</code>,<code>cellcenterz</code>: i-th component of these vectors contain the x, y and z coordinates of geometric cell centers of cell with ID i</li><li><code>faces</code>: Array with three columns. The three entries n1, n2, c1 in a cell are indices and describe a line between nodes with IDs n1 and n2 and this boundary belongs to cell with ID c1. </li><li><code>cellneighboursarray</code>: The i-th line contains the indices of the neighbouring cells of cell with ID i. Number of columns is given by maxnumberofneighbours. Array is initialized with -9 and only the positive entries are considered.</li><li><code>celldirection</code>: The i-th line contains the x, y and z coordinates of the unit normal vector which is projected on the cell to define the cell coordinate system for cell with ID i.</li><li><code>cellthickness</code>: The i-th line contains the thickness of cell with ID i.</li><li><code>maxnumberofneighbours</code>: Number of columns of array <code>cellneighboursarray</code>. Default value is <code>10</code>. If more cell neighbours in the mesh, an error occurs and this value must be increased. </li></ul><p>Return: Data structure with</p><ul><li><code>cellvolume :: Vector{Float}</code></li><li><code>cellcentertocellcenterx :: Array{Float,2}</code></li><li><code>cellcentertocellcentery :: Array{Float,2}</code> </li><li><code>T11 :: Array{Float,2}</code></li><li><code>T12 :: Array{Float,2}</code></li><li><code>T21 :: Array{Float,2}</code></li><li><code>T22 :: Array{Float,2}</code></li><li><code>cellfacenormalx :: Array{Float,2}</code></li><li><code>cellfacenormaly :: Array{Float,2}</code></li><li><code>cellfacearea :: Array{Float,2}</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.assign_parameters-Tuple{Any}" href="#rtmsim.assign_parameters-Tuple{Any}"><code>rtmsim.assign_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function assign_parameters(input_struct)</code></pre><p>Assign properties to cells.</p><p>Arguments: Data structure with</p><ul><li><code>i_interactive :: Int</code></li><li><code>celltype :: Vector{Int}</code></li><li><code>patchparameters0 :: Vector{Float}</code></li><li><code>patchparameters1 :: Vector{Float}</code></li><li><code>patchparameters2 :: Vector{Float}</code></li><li><code>patchparameters3 :: Vector{Float}</code></li><li><code>patchparameters4 :: Vector{Float}</code></li><li><code>patchtype1val :: Int</code></li><li><code>patchtype2val :: Int</code></li><li><code>patchtype3val :: Int</code></li><li><code>patchtype4val :: Int</code></li><li><code>patchids1 :: Vector{Int}</code></li><li><code>patchids2 :: Vector{Int}</code></li><li><code>patchids3 :: Vector{Int}</code></li><li><code>patchids4 :: Vector{Int}</code></li><li><code>inletpatchids :: Vector{Int}</code></li><li><code>mu_resin_val :: Float</code></li><li><code>N :: Int</code></li></ul><p>Meaning of the arguments:</p><ul><li><code>i_interactive</code>: 1..if pressure inlet cells are selected manually, 0..else</li><li><code>celltype[i]</code>: Describes cell type. -1..pressure inlet, -2..pressure outlet, -3..cell with wall boundary, 1..interior cell</li><li><code>patchparameters0</code>,<code>patchparameters1</code>,<code>patchparameters2</code>,<code>patchparameters3</code>,<code>patchparameters4</code> :: 7-element vector with parameters for the main preform and the four sets if used as patch. The seven elements are cellporosity,cellthickness,cellpermeability,cellalpha,celldirection[1],celldirection[2],celldirection[3].</li><li><code>patchtype1val</code>,<code>patchtype2val</code>,<code>patchtype3val</code>,<code>patchtype4val</code> :: Type of patch. 1..</li><li><code>patchids1</code>,<code>patchids2</code>,<code>patchids3</code>,<code>patchids4</code> :: Type of set. 0..ignored, 1..pressure inlet, 2..patch, 3..pressure outlet</li><li><code>inletpatchids</code> :: Vector with the IDs of the cells which are inlet cells.</li><li><code>mu_resin_val</code> :: Kinematic viscosity value.</li><li><code>N</code>: Number of cells.</li></ul><p>Return: Data structure with</p><ul><li><code>cellthickness :: Vector{Float64}</code></li><li><code>cellporosity :: Vector{Float64}</code></li><li><code>cellpermeability :: Vector{Float64}</code></li><li><code>cellalpha :: Vector{Float64}</code></li><li><code>celldirection :: Array{Float64,2}</code></li><li><code>cellviscosity :: Vector{Float64}</code></li><li><code>celltype :: Vector{Int64}</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="rtmsim.create_faces-Tuple{Any}" href="#rtmsim.create_faces-Tuple{Any}"><code>rtmsim.create_faces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function create_faces(input_struct)</code></pre><p>Find the set with the IDs of the neighbouring cells and identify wall cells.</p><p>Arguments: Data structure with</p><ul><li><code>cellgridid :: Array{Int,2}</code></li><li><code>N :: Int</code></li><li><code>maxnumberofneighbours :: Int</code></li></ul><p>Meaning of the arguments:</p><ul><li><code>cellgridid</code>: The i-th line contains the three IDs of the nodes which form the cell</li><li><code>N</code>: Number of cells.</li><li><code>maxnumberofneighbours</code>: Number of columns of array <code>cellneighboursarray</code>. Default value is <code>10</code>. If more cell neighbours in the mesh, an error occurs and this value must be increased. </li></ul><p>Return: Data structure with</p><ul><li><code>faces :: Array{Int,2}</code></li><li><code>cellneighboursarray :: Array{Int,2}</code></li><li><code>celltype :: Vector{Int}</code></li></ul></div></section></article><h2 id="Additional-features"><a class="docs-heading-anchor" href="#Additional-features">Additional features</a><a id="Additional-features-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-features" title="Permalink"></a></h2><p>The source code is prepared for the following extensions:</p><ul><li>Import mesh file in different format. Selection is based on the extension of the mesh file.</li><li>Input parameter <code>i_model</code> (for iso-thermal RTM <code>=1</code>) is used for adding additional functionalities. E.g. adding temperature and degree-of-cure equations with variable resin viscosity or for VARI with variable porosity, permeability and cavity thickness.</li><li>Parameter <code>i_method</code> in the functions for numerical differentiation and flux functions can be used to implement different numerical schemes. E.g. gradient limiter or second-order upwinding.</li></ul><p>If you are interested, please have a look at the contribution item in the <a href="https://github.com/obertscheiderfhwn/RTMsim/community">community standards</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« RTMsim</a><a class="docs-footer-nextpage" href="../installation/">Installation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 5 March 2023 20:19">Sunday 5 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
